\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Date 1 & 1.0 & Notes\\
Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \wss{give url}

\wss{Also add any additional symbols, abbreviations or acronyms}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
\wss{Fill in your project name and description}

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{...}.  \wss{provide the url for your repo}

\section{Notation}

\wss{You should describe your notation.  You can use what is below as
  a starting point.}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
  \centering
  \begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
  \toprule
  \textbf{Level 1} & \textbf{Level 2}\\
  \midrule
  
  {Hardware-Hiding Module} & ~ \\
  \midrule
  
  \multirow{7}{0.3\textwidth}{Behaviour-Hiding Module} 
  & Config Loading Module\\
  & Data Loading Module\\
  & Model Module\\
  & Checkpointing Module\\
  & Training Module\\
  & Inference Module\\
  & Loss Module\\ 
  & Evaluation Module\\
  & Optimization Module\\
  & Data Processing Module\\
  \midrule
  
  \multirow{3}{0.3\textwidth}{Software Decision Module}
  & Plotting Module\\
  & PyTorch Module\\
  & Logging Module\\
  \bottomrule
  
  \end{tabular}
  \caption{Module Hierarchy}
  \label{TblMH}
  \end{table}

\newpage
~\newpage

\section{MIS of Training Module} \label{Module} 

\subsection{Module}



\subsection{Uses}
\begin{enumerate}
  \item PyTorch Dataloader (\href{https://pytorch.org/tutorials/beginner/basics/data_tutorial.html}{PyTorch Documentation})
  \item PyTorch Optimizer (\href{https://pytorch.org/docs/stable/optim.html}{PyTorch Documentation})
  \item PyTorch Loss (\href{https://pytorch.org/docs/stable/nn.html#loss-functions}{PyTorch Documentation})
  \item Model
  \item Checkpoint
  \item Logger
\end{enumerate}

\subsection{Syntax}



\subsubsection{Exported Constants}



\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm}|p{6cm}|p{2cm}|p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
train & PyTorch Dataloader (Eval), PyTorch Dataloader (Training), PyTorch Optimizer, Model, Loss& - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}


\subsubsection{Environment Variables}


\subsubsection{Assumptions}


\subsubsection{Access Routine Semantics}


\noindent train():
\begin{itemize}
\item transition: N/A 
\item output: N/A
\item exception: N/A
\end{itemize}

\subsubsection{Local Functions}

\begin{enumerate}
  \item \textbf{trainEpoch}(trainDataloader, optimizer, model, loss):
  \begin{enumerate}
    \item \textbf{Input:} The dataloader of training data, the model to be optimized, the ADAM optimizer, and the loss function for backpropagation.
    \item \textbf{Method Description:} This method optimizes the model over the input training data to lower the given loss that the model incurs. 
    Statistics describing the performance of the model (loss) over the training set are logged using the global logger.
    \item \textbf{Output:} N/A 
  \end{enumerate}
  \item \textbf{evalModel}(evalDataloader, model):
  \begin{enumerate}
    \item \textbf{Input:} The dataloader of evaluation data and the model to be evaluated.
    \item \textbf{Method Description:} This method collects the mAP metrics obtained from applying the current model to the evaluation dataset. These
    metrics are logged using the global logger. The current state of the model is additionally saved using the checkpointing system.
    \item \textbf{Output:} N/A
  \end{enumerate}
\end{enumerate}

\newpage

\section{MIS of Inference Module} \label{Module} 

\subsection{Module}



\subsection{Uses}
\begin{itemize}
  \item PyTorch Dataloader (\href{https://pytorch.org/tutorials/beginner/basics/data_tutorial.html}{PyTorch Documentation})
  \item Checkpoint
  \item Model
  \item Logger
\end{itemize}

\subsection{Syntax}



\subsubsection{Exported Constants}



\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm}|p{6cm}|p{2cm}|p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
inference & Images, LiDAR, Bounding Boxes, Model, Checkpoint & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}


\subsubsection{Environment Variables}


\subsubsection{Assumptions}



\subsubsection{Access Routine Semantics}
\noindent inference():
\begin{itemize}
\item transition: N/A 
\item output: N/A
\item exception: N/A
\end{itemize}

\subsubsection{Local Functions}
\begin{enumerate}
  \item \textbf{getPredBoundingBoxes}(Images, LiDAR, Model):
  \begin{enumerate}
    \item \textbf{Input:} The model to be used for inference in addition to the input data (multiview camera images and a LiDAR pointcloud).
    \item \textbf{Method Description:} This method uses the model to get a set of predicted bounding boxes for the given input data.
    \item \textbf{Output:} The predicted bounding boxes.
  \end{enumerate}
  \item \textbf{plotBoundingBoxes}(LiDAR, gtBoundingBoxes, predBoundingBoxes):
  \begin{enumerate}
    \item \textbf{Input:} The input LiDAR pointcloud alongside the ground truth and predicted bounding boxes for this scene. 
    \item \textbf{Method Description:} This method displays a 3D plot of the ground truth and predicted bounding boxes on the input LiDAR pointcloud to allow for visual inspection (using the plotting module).
    \item \textbf{Output:} N/A
  \end{enumerate}
\end{enumerate}

\newpage

\section{MIS of Evaluation Module} \label{Module} 

\subsection{Module}



\subsection{Uses}
\begin{itemize}
  \item PyTorch Dataloader (\href{https://pytorch.org/tutorials/beginner/basics/data_tutorial.html}{PyTorch Documentation})
  \item Model
  \item Checkpoint
\end{itemize}


\subsection{Syntax}



\subsubsection{Exported Constants}



\subsubsection{Exported Access Programs}

\begin{center}
  \begin{tabular}{p{2cm}|p{6cm}|p{2cm}|p{2cm}}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
  \hline
  eval & PyTorch Dataloader (Eval), Model, Checkpoint (Optional) & Evaluation Metrics & - \\
  \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}


\subsubsection{Environment Variables}


\subsubsection{Assumptions}



\subsubsection{Access Routine Semantics}
\noindent eval():
\begin{itemize}
\item transition: N/A 
\item output: This function will run the input model over the evaluation loader and collect the mAP statistics over this set of data. These statistics will then be returned as output. If a checkpoint is passed in, the model will first load the given checkpoint.
\item exception: N/A
\end{itemize}

\subsubsection{Local Functions}


\newpage

\section{MIS of Model Module} \label{Module} 

\subsection{Module}

\subsection{Uses}
\begin{itemize}
  \item Is a subclass of PyTorch Module (\href{https://pytorch.org/docs/stable/generated/torch.nn.Module.html}{PyTorch Documentation})
  \item Equivariant Layers
  \item OpenPCDet Layers
  \item Configuration
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{tabular}{p{2cm}|p{6cm}|p{2cm}|p{2cm}}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
  \hline
  init & - & - & - \\
  \hline
  forward & Images, LiDAR & Predicted Bounding Boxes & - \\
  \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item pcdetLayers
  \item eqLayers
\end{itemize}

\subsubsection{Environment Variables}


\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}
\noindent init():
\begin{itemize}
\item transition: This function will load the model-related configuration from the global configuration module and will then create the OpenPCDet and Equivariant Layers accordingly. References to these layers will be stored in the pcdetLayers and eqLayers state variables. 
\item output: N/A
\item exception: N/A
\end{itemize}

\noindent forward():
\begin{itemize}
\item transition: N/A 
\item output: This function will run the input data (LiDAR and Images) through the OpenPCDet and Equivariant layers to produce a set of predicted bounding boxes. These predicted bounding boxes will then be returned. 
\item exception: N/A
\end{itemize}

\subsubsection{Local Functions}


\newpage

\section{MIS of Loss Module} \label{Module} 

\subsection{Module}



\subsection{Uses}

\begin{itemize}
  \item Is a subclass of PyTorch Loss (\href{https://pytorch.org/docs/stable/nn.html#loss-functions}{PyTorch Documentation})
  \item Configuration
\end{itemize}

\subsection{Syntax}



\subsubsection{Exported Constants}



\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm}|p{6cm}|p{4cm}|p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
init & - & - & - \\
\hline
forward & Predicted Bounding Boxes, Ground Truth Bounding Boxes & Loss Value & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item hyperparameters
\end{itemize}

\subsubsection{Environment Variables}

\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}
\noindent init():
\begin{itemize}
\item transition: This method will set the loss module's hyperparamters according to the loss-related configuration from the global configuration module. 
\item output: N/A
\item exception: N/A
\end{itemize}

\noindent forward():
\begin{itemize}
\item transition: N/A 
\item output: This method will use the predicted and ground truth bounding boxes to regress and output a loss value.
\item exception: N/A
\end{itemize}

\subsubsection{Local Functions}

\newpage

\section{MIS of Optimizer Module} \label{Module} 

\subsection{Module}



\subsection{Uses}
\begin{itemize}
  \item Is a wrapper around the PyTorch ADAM Optimizer (\href{https://pytorch.org/docs/stable/optim.html}{PyTorch Documentation})
  \item PyTorch Parameter (\href{https://pytorch.org/docs/stable/generated/torch.nn.parameter.Parameter.html}{PyTorch Documentation})
  \item Configuration
\end{itemize}

\subsection{Syntax}



\subsubsection{Exported Constants}



\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm}|p{6cm}|p{2cm}|p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
init & Model Parameters & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item hyperparameters
  \item modelParameters
\end{itemize}

\subsubsection{Environment Variables}



\subsubsection{Assumptions}



\subsubsection{Access Routine Semantics}
\noindent init():
\begin{itemize}
\item transition: This method will set the loss module's hyperparameters according to the optimizer-related configuration from the global configuration module. It will also save a reference to passed in model parameters in the modelParameters state variable.
\item output: N/A
\item exception: N/A
\end{itemize}

\subsubsection{Local Functions}

\newpage

\section{MIS of Plotting Module} \label{Module} 

\subsection{Module}



\subsection{Uses}
\begin{itemize}
  \item Open3D Oriented Bounding Boxes (\href{https://www.open3d.org/docs/latest/python_api/open3d.geometry.OrientedBoundingBox.html}{Open3D Documentation})
  \item Open3D Pointclouds (\href{https://www.open3d.org/docs/release/python_api/open3d.geometry.PointCloud.html}{Open3D Documentation})
  \item Open3D in general (\href{https://www.open3d.org/docs/release/introduction.html}{Open3D Documentation})
\end{itemize}

\subsection{Syntax}



\subsubsection{Exported Constants}



\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm}|p{6cm}|p{2cm}|p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
plot & Ground Truth Bounding Boxes, Predicted Bounding Boxes, LiDAR & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\subsubsection{Environment Variables}

\begin{itemize}
  \item Computer Screen
\end{itemize}

\subsubsection{Assumptions}



\subsubsection{Access Routine Semantics}
\noindent plot():
\begin{itemize}
\item transition: The LiDAR pointcloud is first converted into an Open3D Pointcloud. Then, the bounding boxes are converted into the Open3d OrientedBoundingBox type. Finally, these are all visualized together in a single 3D plot using Open3D's draw\_geometries function. This outputs a plot and thus updates the computer screen environment variable.
\item output: N/A
\item exception: N/A
\end{itemize}

\subsubsection{Local Functions}

\newpage

\section{MIS of Checkpoint Module} \label{Module} 

\subsection{Module}



\subsection{Uses}
\begin{itemize}
  \item PyTorch Model (\href{https://pytorch.org/docs/stable/generated/torch.nn.Module.html}{PyTorch Documentation})
  \item PyTorch State Dictionary (\href{https://pytorch.org/tutorials/beginner/saving_loading_models.html}{PyTorch Documentation})
\end{itemize}

\subsection{Syntax}



\subsubsection{Exported Constants}



\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm}|p{5cm}|p{2cm}|p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
saveCheckpoint & Model, Checkpoint Path & - & - \\
\hline
loadCheckpoint & Model, Checkpoint Path & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}



\subsubsection{Environment Variables}

\begin{itemize}
  \item File System
\end{itemize}

\subsubsection{Assumptions}



\subsubsection{Access Routine Semantics}
\noindent saveCheckpoint():
\begin{itemize}
\item transition: The input model's state dictionary is saved to a pytorch tensor file at the input path. 
\item output: N/A
\item exception: N/A
\end{itemize}


\noindent loadCheckpoint():
\begin{itemize}
\item transition: The input model's parameters are set using the state dictionary saved at the input path.
\item output: N/A
\item exception: N/A
\end{itemize}


\subsubsection{Local Functions}

\newpage

\section{MIS of Data Module} \label{Module} 

\subsection{Module}



\subsection{Uses}
\begin{enumerate}
  \item PyTorch Dataset and Dataloader (\href{https://pytorch.org/tutorials/beginner/basics/data_tutorial.html}{PyTorch Documentation})
  \item Configuration
\end{enumerate}

\subsection{Syntax}



\subsubsection{Exported Constants}



\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm}|p{5cm}|p{4cm}|p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
init & isEval Boolean & - & - \\
\hline
getDataloader & - & PyTorch Dataloader & -  \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item dataset
\end{itemize}

\subsubsection{Environment Variables}
\begin{enumerate}
  \item File System
\end{enumerate}

\subsubsection{Assumptions}



\subsubsection{Access Routine Semantics}
\noindent init():
\begin{itemize}
\item transition: This function will load the data-related configuration from the global configuration module and will then create the dataset accordingly.
This dataset will either be the NuScenes (\cite{caesar2020nuscenes}) or the Waymo (\cite{sun2020scalability}) dataset for now and will be stored in the dataset state variable. If isEval is false,
the training portion of the dataset will be loaded. If isEval is true, the evaluation portion of the dataset will be loaded.
\item output: N/A
\item exception: N/A
\end{itemize}

\noindent getDataloader():
\begin{itemize}
  \item transition: N/A
  \item output: This function will use the dataset state variable to create a PyTorch Dataloader which will then be returned.
  \item exception: N/A
\end{itemize}

\subsubsection{Local Functions}

\newpage

\section{MIS of Equivariant Layers Module} \label{Module} 

This module is meant to represent the equivariant layers I will be adding into the OpenPCDet repository for the novel part
of my project. To provide context for the reader, equivariant layers
refer to neural network layers that preserve input transformations when generating output features. For example, a rotated image of a cat 
will result in similarly rotated output features (when compared to features generated from an upright image of a cat). This work by Cohen et Al. (\cite{cohen2016group})
more clearly explains this concept.


This module will encapsulate two different types of equivariant layers. The first of these is steerable kernel 
equivariant CNNs (\cite{cohen2016steerable}) extended to include both 2D and 3D symmetries using the escnn repository (\cite{cesa2022a}). 
The second of these is equivariant transformer networks (\cite{tai2019equivariant}). Existing OpenPCDet layers can essentially then be directly
swapped out for these equivariant alternatives. 

\subsection{Module}



\subsection{Uses}
\begin{itemize}
  \item PyTorch Parameter (\href{https://pytorch.org/docs/stable/generated/torch.nn.parameter.Parameter.html}{PyTorch Documentation})
  \item Steerable CNNs (\cite{cesa2022a})
  \item Equivariant Transformers (\cite{tai2019equivariant})
\end{itemize}

\subsection{Syntax}



\subsubsection{Exported Constants}



\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm}|p{6cm}|p{4cm}|p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
init & - & - & - \\
\hline
forward & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item layerParameters
\end{itemize}

\subsubsection{Environment Variables}



\subsubsection{Assumptions}



\subsubsection{Access Routine Semantics}
\noindent init():
\begin{itemize}
\item transition: The parameters for the layer are randomly initialized according to a uniform distribution around 0 (saved in the layerParameters state variable). 
\item output: N/A
\item exception: N/A
\end{itemize}


\noindent forward():
\begin{itemize}
\item output:
\begin{itemize}
  \item \textbf{For the CNN case:} Since the CNN case is simpler, the math relating to it can be shown here itself. The result $y$ of this formula is returned:
  \newline\newline
  $y[m,n](k,x)=\sum_{i=-w}^{w}\sum_{j=-h}^{h}k[w+i,h+j]x[m+i,n+j]\rightarrow{}y(k,x)=k*x$ \newline
  such that if $x_{2}=gx_{1}$ for some $g$ in the group of considered transformations, $y(x_{2})=\rho(g)y(x_{1})$
  for a single function $\rho$.
  \newline
  \item \textbf{For the Transformer case:} The math here is more complicated and so I will simply refer the reader to the paper by Tai et. al (\cite{tai2019equivariant}). The output of this layer is returned. Generally though for attention function f,
  the following can be written similar to the CNN case:
  $x_{2}=gx_{1} \rightarrow{} y(k,x_{2})=\rho(g)y(k,x_{1})$ 
\end{itemize}
\end{itemize}

\subsubsection{Local Functions}

\newpage

\section{MIS of OpenPCDet Layers Module} \label{Module} 
This module is simply used to represent the existing layers in the OpenPCDet library (\cite{openpcdet2020}).
Rather than highlight specific relevant layer types and modules, I would encourage the reader to read through the BEVFusion (\cite{liang2022bevfusion})
configuration file (\href{https://github.com/open-mmlab/OpenPCDet/blob/master/tools/cfgs/nuscenes_models/bevfusion.yaml}{BEVFusion Config File}) and 
associated code sections (\href{https://github.com/open-mmlab/OpenPCDet/tree/master/pcdet/models}{Model-Related OpenPCDet Code}).

\newpage

\section{MIS of PyTorch Module} \label{Module} 
This module is simply used to represent the PyTorch library referenced in the other modules.
The main list of components that are used from this library is as follows:
\begin{itemize}
  \item PyTorch Module (\href{https://pytorch.org/docs/stable/generated/torch.nn.Module.html}{PyTorch Documentation})
  \item PyTorch Dataloader (\href{https://pytorch.org/tutorials/beginner/basics/data_tutorial.html}{PyTorch Documentation})
  \item PyTorch Optimizer (\href{https://pytorch.org/docs/stable/optim.html}{PyTorch Documentation})
  \item PyTorch Loss (\href{https://pytorch.org/docs/stable/nn.html#loss-functions}{PyTorch Documentation})
  \item PyTorch State Dictionary (\href{https://pytorch.org/tutorials/beginner/saving_loading_models.html}{PyTorch Documentation})
  \item PyTorch Parameter (\href{https://pytorch.org/docs/stable/generated/torch.nn.parameter.Parameter.html}{PyTorch Documentation})
\end{itemize}

\newpage

\section{MIS of Config Module} \label{Module} 

\subsection{Module}



\subsection{Uses}


\subsection{Syntax}



\subsubsection{Exported Constants}
\begin{itemize}
  \item CONFIG\_PATH
\end{itemize}


\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm}|p{6cm}|p{4cm}|p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
init & - & - & - \\
\hline
getModelConfig & - & - & - \\
\hline
getDataConfig & - & - & - \\
\hline
getOptimConfig & - & - & - \\
\hline
getLossConfig & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item modelConfig
  \item dataConfig 
  \item optimConfig 
  \item lossConfig
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item File System
\end{itemize}

\subsubsection{Assumptions}



\subsubsection{Access Routine Semantics}
\noindent init():
\begin{itemize}
  \item transition: This method loads the yaml configuration file stored at the predefined constant path CONFIG\_PATH. Then, the dictionary loaded from this JSON file is split into model, data, optimizer, and loss sections. Each of these is saved to the corresponding state variable for this module.
  \item output: N/A
  \item exception: N/A
\end{itemize}

\noindent getModelConfig():
\begin{itemize}
\item transition: N/A 
\item output: This method returns the configuration parameters for the model module.
\item exception: N/A
\end{itemize}

\noindent getDataConfig():
\begin{itemize}
  \item transition: N/A
  \item output: This method returns the configuration parameters for the data module.
  \item exception: N/A
\end{itemize}

\noindent getOptimConfig():
\begin{itemize}
  \item transition: N/A
  \item output: This method returns the configuration parameters for the optimizer module.
  \item exception: N/A
\end{itemize}

\noindent getLossConfig():
\begin{itemize}
  \item transition: N/A
  \item output: This method returns the configuration parameters for the loss module.
  \item exception: N/A
\end{itemize}

\subsubsection{Local Functions}

\newpage

\section{MIS of Data Processing Module} \label{Module} 

\subsection{Module}



\subsection{Uses}
\begin{itemize}
  \item 
\end{itemize}

\subsection{Syntax}



\subsubsection{Exported Constants}



\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm}|p{6cm}|p{2cm}|p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
process & Image Path, LiDAR Path & Images, LiDAR & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}



\subsubsection{Environment Variables}



\subsubsection{Assumptions}

\newpage



\subsubsection{Access Routine Semantics}
\noindent process():
\begin{itemize}
\item transition: N/A 
\item output: Loads the multiview images and LiDAR pointcloud from their respective files and converts them into a standard PyTorch Tensor format that can be used by the model. The Tensor form of the multiview images and the LiDAR pointcloud are returned.
\item exception: N/A
\end{itemize}

\subsubsection{Local Functions}


\section{References}
\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage




\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\newpage{}

\section*{Appendix --- Reflection}

\wss{Not required for CAS 741 projects}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.

\input{../../Reflection.tex}

\begin{enumerate}
  \item What went well while writing this deliverable? 
  \item What pain points did you experience during this deliverable, and how
    did you resolve them?
  \item Which of your design decisions stemmed from speaking to your client(s)
  or a proxy (e.g. your peers, stakeholders, potential users)? For those that
  were not, why, and where did they come from?
  \item While creating the design doc, what parts of your other documents (e.g.
  requirements, hazard analysis, etc), it any, needed to be changed, and why?
  \item What are the limitations of your solution?  Put another way, given
  unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)
  \item Give a brief overview of other design solutions you considered.  What
  are the benefits and tradeoffs of those other designs compared with the chosen
  design?  From all the potential options, why did you select the documented design?
  (LO\_Explores)
\end{enumerate}


\end{document}